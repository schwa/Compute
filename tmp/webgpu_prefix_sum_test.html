<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Prefix Sum Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .output {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
    </style>
</head>
<body>
    <h1>WebGPU Prefix Sum Test</h1>
    
    <div class="controls">
        <button id="runTest">Run Prefix Sum Test</button>
        <button id="clearOutput">Clear Output</button>
    </div>
    
    <div id="output" class="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runTestBtn = document.getElementById('runTest');
        const clearOutputBtn = document.getElementById('clearOutput');

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${timestamp}] `;
            outputDiv.textContent += prefix + message + '\n';
            
            if (type === 'error') {
                outputDiv.className = 'output error';
            } else if (type === 'success') {
                outputDiv.className = 'output success';
            } else {
                outputDiv.className = 'output';
            }
            
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function clearOutput() {
            outputDiv.textContent = '';
            outputDiv.className = 'output';
        }

        // WebGPU prefix sum shader
        const prefixSumSource = /* wgsl */ `
@group(0) @binding(0) var<storage, read_write> items: array<u32>;
@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;

override WORKGROUP_SIZE_X: u32;
override WORKGROUP_SIZE_Y: u32;
override THREADS_PER_WORKGROUP: u32;
override ITEMS_PER_WORKGROUP: u32;
override ELEMENT_COUNT: u32;

var<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP>;

@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)
fn reduce_downsweep(
    @builtin(workgroup_id) w_id: vec3<u32>,
    @builtin(num_workgroups) w_dim: vec3<u32>,
    @builtin(local_invocation_index) TID: u32,
) {
    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;
    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;
    let GID = WID + TID;
    
    let ELM_TID = TID * 2;
    let ELM_GID = GID * 2;
    
    // Load input to shared memory
    temp[ELM_TID]     = select(items[ELM_GID], 0, ELM_GID >= ELEMENT_COUNT);
    temp[ELM_TID + 1] = select(items[ELM_GID + 1], 0, ELM_GID + 1 >= ELEMENT_COUNT);

    var offset: u32 = 1;

    // Up-sweep (reduce) phase
    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {
        workgroupBarrier();

        if (TID < d) {
            var ai: u32 = offset * (ELM_TID + 1) - 1;
            var bi: u32 = offset * (ELM_TID + 2) - 1;
            temp[bi] += temp[ai];
        }

        offset *= 2;
    }

    // Save workgroup sum and clear last element
    if (TID == 0) {
        let last_offset = ITEMS_PER_WORKGROUP - 1;

        blockSums[WORKGROUP_ID] = temp[last_offset];
        temp[last_offset] = 0;
    }

    // Down-sweep phase
    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {
        offset >>= 1;
        workgroupBarrier();

        if (TID < d) {
            var ai: u32 = offset * (ELM_TID + 1) - 1;
            var bi: u32 = offset * (ELM_TID + 2) - 1;

            let t: u32 = temp[ai];
            temp[ai] = temp[bi];
            temp[bi] += t;
        }
    }
    workgroupBarrier();

    // Copy result from shared memory to global memory
    if (ELM_GID >= ELEMENT_COUNT) {
        return;
    }
    items[ELM_GID] = temp[ELM_TID];

    if (ELM_GID + 1 >= ELEMENT_COUNT) {
        return;
    }
    items[ELM_GID + 1] = temp[ELM_TID + 1];
}`;

        async function testWebGPUPrefixSum() {
            try {
                log('Starting WebGPU prefix sum test...');
                
                // Check for WebGPU support
                if (!navigator.gpu) {
                    throw new Error('WebGPU is not supported in this browser');
                }
                
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('No appropriate WebGPU adapter found');
                }
                
                const device = await adapter.requestDevice();
                log('WebGPU device created successfully');
                
                // Test with 513 elements
                const elementCount = 513;
                const input = new Uint32Array(Array.from({length: elementCount}, (_, i) => i));
                log(`Testing with ${elementCount} elements: [${input.slice(0, 10).join(', ')}...]`);
                
                const inputBuffer = device.createBuffer({
                    size: input.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
                });
                
                device.queue.writeBuffer(inputBuffer, 0, input);
                
                const workgroupSize = { x: 16, y: 16 };
                const threadsPerWorkgroup = workgroupSize.x * workgroupSize.y;
                const itemsPerWorkgroup = 2 * threadsPerWorkgroup;
                
                log(`Workgroup size: ${workgroupSize.x}x${workgroupSize.y}, threads per workgroup: ${threadsPerWorkgroup}, items per workgroup: ${itemsPerWorkgroup}`);
                
                const workgroupCount = Math.ceil(elementCount / itemsPerWorkgroup);
                log(`Number of workgroups: ${workgroupCount}`);
                
                const blockSumBuffer = device.createBuffer({
                    size: workgroupCount * 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
                });
                
                const shaderModule = device.createShaderModule({
                    code: prefixSumSource
                });
                
                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.COMPUTE,
                            buffer: { type: 'storage' }
                        },
                        {
                            binding: 1,
                            visibility: GPUShaderStage.COMPUTE,
                            buffer: { type: 'storage' }
                        }
                    ]
                });
                
                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: inputBuffer } },
                        { binding: 1, resource: { buffer: blockSumBuffer } }
                    ]
                });
                
                const pipeline = device.createComputePipeline({
                    layout: device.createPipelineLayout({
                        bindGroupLayouts: [bindGroupLayout]
                    }),
                    compute: {
                        module: shaderModule,
                        entryPoint: 'reduce_downsweep',
                        constants: {
                            'WORKGROUP_SIZE_X': workgroupSize.x,
                            'WORKGROUP_SIZE_Y': workgroupSize.y,
                            'THREADS_PER_WORKGROUP': threadsPerWorkgroup,
                            'ITEMS_PER_WORKGROUP': itemsPerWorkgroup,
                            'ELEMENT_COUNT': elementCount,
                        }
                    }
                });
                
                log('Pipeline created successfully');
                
                const commandEncoder = device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(pipeline);
                computePass.setBindGroup(0, bindGroup);
                computePass.dispatchWorkgroups(workgroupCount);
                computePass.end();
                
                const readBuffer = device.createBuffer({
                    size: input.byteLength,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                });
                
                commandEncoder.copyBufferToBuffer(inputBuffer, 0, readBuffer, 0, input.byteLength);
                device.queue.submit([commandEncoder.finish()]);
                
                log('Compute pass dispatched, waiting for results...');
                
                await readBuffer.mapAsync(GPUMapMode.READ);
                const result = new Uint32Array(readBuffer.getMappedRange().slice());
                readBuffer.unmap();
                
                log(`WebGPU result (${result.length} elements): [${result.slice(0, 10).join(', ')}...${result.slice(-10).join(', ')}]`);
                log(`Last element: ${result[elementCount - 1]}`);
                
                // Calculate expected result (prefix sum) using CPU
                log('Computing CPU prefix sum for comparison...');
                const expected = [0];
                for (let i = 0; i < elementCount - 1; i++) {
                    expected.push(expected[expected.length - 1] + i);
                }
                
                log(`CPU result (${expected.length} elements): [${expected.slice(0, 10).join(', ')}...${expected.slice(-10).join(', ')}]`);
                log(`Expected last element: ${expected[elementCount - 1]}`);
                
                const isCorrect = result[elementCount - 1] === expected[elementCount - 1];
                log(`Result matches expected: ${isCorrect}`, isCorrect ? 'success' : 'error');
                
                if (isCorrect) {
                    log('✓ WebGPU prefix sum test PASSED!', 'success');
                } else {
                    log('✗ WebGPU prefix sum test FAILED!', 'error');
                    
                    // Show more detailed comparison for debugging
                    log('First 10 elements comparison:');
                    for (let i = 0; i < 10; i++) {
                        const match = result[i] === expected[i];
                        log(`  [${i}]: got ${result[i]}, expected ${expected[i]} ${match ? '✓' : '✗'}`);
                    }
                }
                
                device.destroy();
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }

        // Event listeners
        runTestBtn.addEventListener('click', async () => {
            runTestBtn.disabled = true;
            clearOutput();
            await testWebGPUPrefixSum();
            runTestBtn.disabled = false;
        });

        clearOutputBtn.addEventListener('click', clearOutput);

        // Initial message
        log('WebGPU Prefix Sum Test Ready');
        log('Click "Run Prefix Sum Test" to start the test');
    </script>
</body>
</html>